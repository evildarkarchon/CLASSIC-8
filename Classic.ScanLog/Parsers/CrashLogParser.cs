using System.Text.RegularExpressions;
using Classic.Core.Interfaces;
using Classic.Core.Models;
using Classic.ScanLog.Models;
using Microsoft.Extensions.Logging;

namespace Classic.ScanLog.Parsers;

/// <summary>
///     Parses Bethesda game crash logs generated by Buffout 4.
///     Implements the ICrashLogParser interface for crash log analysis.
/// </summary>
public class CrashLogParser : ICrashLogParser
{
    private readonly ScanLogConfiguration _configuration;
    private readonly ILogger<CrashLogParser> _logger;
    private readonly ScanLogPatterns _patterns;

    public CrashLogParser(
        ILogger<CrashLogParser> logger,
        ScanLogConfiguration configuration)
    {
        _logger = logger;
        _configuration = configuration;
        _patterns = configuration.Patterns;
    }

    /// <summary>
    ///     Parses a crash log file asynchronously
    /// </summary>
    public async Task<CrashLog> ParseCrashLogAsync(string filePath, CancellationToken cancellationToken = default)
    {
        try
        {
            _logger.LogDebug("Starting parse of crash log: {FilePath}", filePath);

            var content = await File.ReadAllLinesAsync(filePath, cancellationToken);
            var fileName = Path.GetFileName(filePath);

            return await ParseCrashLogFromContentAsync(content, fileName, cancellationToken);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to parse crash log file: {FilePath}", filePath);
            throw;
        }
    }

    /// <summary>
    ///     Parses crash log content from memory asynchronously
    /// </summary>
    public async Task<CrashLog> ParseCrashLogFromContentAsync(string[] content, string fileName,
        CancellationToken cancellationToken = default)
    {
        try
        {
            var crashLog = new CrashLog
            {
                FileName = fileName,
                FilePath = fileName,
                RawContent = content.ToList(),
                DateCreated = ExtractDateFromFileName(fileName)
            };

            // Extract basic information from header
            await ExtractHeaderInformationAsync(crashLog, content, cancellationToken);

            // Extract all segments
            crashLog.Segments = await ExtractSegmentsAsync(content, cancellationToken);

            _logger.LogDebug("Successfully parsed crash log: {FileName}", fileName);
            return crashLog;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to parse crash log content for: {FileName}", fileName);
            throw;
        }
    }

    /// <summary>
    ///     Extracts structured segments from crash log content
    /// </summary>
    public async Task<Dictionary<string, List<string>>> ExtractSegmentsAsync(string[] content,
        CancellationToken cancellationToken = default)
    {
        return await Task.Run(() =>
        {
            var segments = new Dictionary<string, List<string>>();
            string? currentSegment = null;
            var currentLines = new List<string>();

            for (var i = 0; i < content.Length; i++)
            {
                cancellationToken.ThrowIfCancellationRequested();

                var line = content[i].Trim();

                // Check if this line starts a new segment
                var newSegment = DetermineSegmentType(line);

                if (newSegment != null)
                {
                    // Save previous segment if it exists
                    if (currentSegment != null && currentLines.Count > 0)
                        segments[currentSegment] = new List<string>(currentLines);

                    // Start new segment
                    currentSegment = newSegment;
                    currentLines.Clear();
                    currentLines.Add(line); // Include the header line
                }
                else if (currentSegment != null)
                {
                    // Add line to current segment
                    currentLines.Add(line);
                }
                else if (string.IsNullOrEmpty(currentSegment))
                {
                    // Header section before any named segments
                    if (!segments.ContainsKey("Header"))
                        segments["Header"] = new List<string>();
                    segments["Header"].Add(line);
                }
            }

            // Save the last segment
            if (currentSegment != null && currentLines.Count > 0) segments[currentSegment] = currentLines;

            return segments;
        }, cancellationToken);
    }

    /// <summary>
    ///     Extracts basic header information from crash log
    /// </summary>
    private async Task ExtractHeaderInformationAsync(CrashLog crashLog, string[] content,
        CancellationToken cancellationToken)
    {
        await Task.Run(() =>
        {
            // Extract game version (first line)
            if (content.Length > 0)
            {
                var gameVersionMatch = Regex.Match(content[0], _patterns.GameVersionPattern);
                if (gameVersionMatch.Success) crashLog.GameVersion = gameVersionMatch.Groups[2].Value;
            }

            // Extract Buffout version (second line)
            if (content.Length > 1)
            {
                var buffoutMatch = Regex.Match(content[1], _patterns.BuffoutVersionPattern);
                if (buffoutMatch.Success) crashLog.CrashGenVersion = buffoutMatch.Groups[1].Value;
            }

            // Extract main error (third line usually)
            for (var i = 0; i < Math.Min(10, content.Length); i++) // Check first 10 lines
            {
                var errorMatch = Regex.Match(content[i], _patterns.MainErrorPattern);
                if (errorMatch.Success)
                {
                    crashLog.MainError = content[i].Trim();
                    break;
                }
            }
        }, cancellationToken);
    }

    /// <summary>
    ///     Determines what type of segment a line represents
    /// </summary>
    private string? DetermineSegmentType(string line)
    {
        if (string.IsNullOrWhiteSpace(line))
            return null;

        // Check against known patterns
        if (Regex.IsMatch(line, _patterns.PluginSectionPattern))
            return "Plugins";

        if (Regex.IsMatch(line, _patterns.F4SeSectionPattern))
            return "F4SEPlugins";

        if (Regex.IsMatch(line, _patterns.StackSectionPattern))
            return "CallStack";

        if (Regex.IsMatch(line, _patterns.SystemSpecsPattern))
            return "SystemSpecs";

        if (Regex.IsMatch(line, _patterns.RegistersPattern))
            return "Registers";

        if (Regex.IsMatch(line, _patterns.StackPattern))
            return "Stack";

        if (Regex.IsMatch(line, _patterns.ModulesPattern))
            return "Modules";

        // Check for compatibility section
        if (line.Contains("[Compatibility]"))
            return "Compatibility";

        if (line.Contains("[Crashlog]"))
            return "CrashlogSettings";

        if (line.Contains("[Fixes]"))
            return "Fixes";

        if (line.Contains("[Patches]"))
            return "Patches";

        if (line.Contains("[Warnings]"))
            return "Warnings";

        if (line.Contains("[Tweaks]"))
            return "Tweaks";

        return null;
    }

    /// <summary>
    ///     Extracts date from crash log filename
    /// </summary>
    private DateTime ExtractDateFromFileName(string fileName)
    {
        try
        {
            // Expected format: crash-YYYY-MM-DD-HH-MM-SS.log
            var pattern = @"crash-(\d{4})-(\d{2})-(\d{2})-(\d{2})-(\d{2})-(\d{2})";
            var match = Regex.Match(fileName, pattern);

            if (match.Success)
            {
                var year = int.Parse(match.Groups[1].Value);
                var month = int.Parse(match.Groups[2].Value);
                var day = int.Parse(match.Groups[3].Value);
                var hour = int.Parse(match.Groups[4].Value);
                var minute = int.Parse(match.Groups[5].Value);
                var second = int.Parse(match.Groups[6].Value);

                return new DateTime(year, month, day, hour, minute, second);
            }
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to extract date from filename: {FileName}", fileName);
        }

        // Fallback to current time
        return DateTime.UtcNow;
    }
}

/// <summary>
///     Extension methods for CrashLog parsing
/// </summary>
public static class CrashLogParserExtensions
{
    /// <summary>
    ///     Checks if the crash log has a valid plugin list
    /// </summary>
    public static bool HasValidPluginList(this CrashLog crashLog)
    {
        return crashLog.Segments.ContainsKey("Plugins") &&
               crashLog.Segments["Plugins"].Count > 1; // More than just the header
    }

    /// <summary>
    ///     Gets the plugin count information from the crash log
    /// </summary>
    public static (int light, int regular, int total) GetPluginCounts(this CrashLog crashLog)
    {
        if (!crashLog.Segments.TryGetValue("Plugins", out var pluginLines))
            return (0, 0, 0);

        var countPattern = @"Light:\s*(\d+)\s+Regular:\s*(\d+)\s+Total:\s*(\d+)";

        foreach (var line in pluginLines)
        {
            var match = Regex.Match(line, countPattern);
            if (match.Success)
                return (
                    int.Parse(match.Groups[1].Value),
                    int.Parse(match.Groups[2].Value),
                    int.Parse(match.Groups[3].Value)
                );
        }

        return (0, 0, 0);
    }

    /// <summary>
    ///     Extracts system specifications from the crash log
    /// </summary>
    public static SystemAnalysisResult ExtractSystemSpecs(this CrashLog crashLog)
    {
        var result = new SystemAnalysisResult
        {
            GameVersion = crashLog.GameVersion,
            BuffoutVersion = crashLog.CrashGenVersion
        };

        if (!crashLog.Segments.TryGetValue("SystemSpecs", out var specLines))
            return result;

        var osPattern = @"OS:\s*(.+)$";
        var cpuPattern = @"CPU:\s*(.+)$";
        var gpuPattern = @"GPU #\d+:\s*(.+)$";
        var memoryPattern = @"PHYSICAL MEMORY:\s*(.+?)/(.+?)$";

        foreach (var line in specLines)
        {
            var osMatch = Regex.Match(line, osPattern);
            if (osMatch.Success)
            {
                result.OperatingSystem = osMatch.Groups[1].Value.Trim();
                continue;
            }

            var cpuMatch = Regex.Match(line, cpuPattern);
            if (cpuMatch.Success)
            {
                result.Cpu = cpuMatch.Groups[1].Value.Trim();
                continue;
            }

            var gpuMatch = Regex.Match(line, gpuPattern);
            if (gpuMatch.Success)
            {
                result.GpUs.Add(gpuMatch.Groups[1].Value.Trim());
                continue;
            }

            var memoryMatch = Regex.Match(line, memoryPattern);
            if (memoryMatch.Success)
                result.MemoryInfo = $"{memoryMatch.Groups[1].Value.Trim()}/{memoryMatch.Groups[2].Value.Trim()}";
        }

        return result;
    }
}
