using System.Text.RegularExpressions;
using Classic.Core.Interfaces;
using Classic.Core.Models;
using Classic.ScanLog.Models;
using Microsoft.Extensions.Logging;

namespace Classic.ScanLog.Parsers;

/// <summary>
///     Parses Bethesda game crash logs generated by Buffout 4.
///     Implements the ICrashLogParser interface for crash log analysis.
/// </summary>
public class CrashLogParser : ICrashLogParser
{
    private readonly ScanLogConfiguration _configuration;
    private readonly ILogger<CrashLogParser> _logger;
    private readonly ScanLogPatterns _patterns;

    public CrashLogParser(
        ILogger<CrashLogParser> logger,
        ScanLogConfiguration configuration)
    {
        _logger = logger;
        _configuration = configuration;
        _patterns = configuration.Patterns;
    }

    /// <summary>
    ///     Parses a crash log file asynchronously
    /// </summary>
    public async Task<CrashLog> ParseCrashLogAsync(string filePath, CancellationToken cancellationToken = default)
    {
        try
        {
            _logger.LogDebug("Starting parse of crash log: {FilePath}", filePath);

            var content = await File.ReadAllLinesAsync(filePath, cancellationToken);
            var fileName = Path.GetFileName(filePath);

            return await ParseCrashLogFromContentAsync(content, fileName, cancellationToken);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to parse crash log file: {FilePath}", filePath);
            throw;
        }
    }

    /// <summary>
    ///     Parses crash log content from memory asynchronously
    /// </summary>
    public async Task<CrashLog> ParseCrashLogFromContentAsync(string[] content, string fileName,
        CancellationToken cancellationToken = default)
    {
        try
        {
            var crashLog = new CrashLog
            {
                FileName = fileName,
                FilePath = fileName,
                RawContent = content.ToList(),
                DateCreated = ExtractDateFromFileName(fileName)
            };

            // Extract basic information from header
            await ExtractHeaderInformationAsync(crashLog, content, cancellationToken);

            // Extract all segments
            crashLog.Segments = await ExtractSegmentsAsync(content, cancellationToken);

            // Extract plugins as structured data
            crashLog.Plugins = ExtractPluginList(crashLog.Segments);

            _logger.LogDebug("Successfully parsed crash log: {FileName}", fileName);
            return crashLog;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to parse crash log content for: {FileName}", fileName);
            throw;
        }
    }

    /// <summary>
    ///     Extracts structured segments from crash log content using Python-style boundary detection
    /// </summary>
    public async Task<Dictionary<string, List<string>>> ExtractSegmentsAsync(string[] content,
        CancellationToken cancellationToken = default)
    {
        return await Task.Run(() =>
        {
            cancellationToken.ThrowIfCancellationRequested();

            // Define segment boundaries similar to Python implementation
            var segmentBoundaries = new List<(string start, string end)>
            {
                ("\t[Compatibility]", "SYSTEM SPECS:"),        // Compatibility/Crashgen info
                ("SYSTEM SPECS:", "PROBABLE CALL STACK:"),     // System specifications
                ("PROBABLE CALL STACK:", "MODULES:"),          // Call stack information
                ("MODULES:", "F4SE PLUGINS:"),                 // All modules
                ("F4SE PLUGINS:", "PLUGINS:"),                 // XSE/F4SE plugins
                ("PLUGINS:", "EOF")                            // Game plugins
            };

            var segmentNames = new[] 
            { 
                "Compatibility", "SystemSpecs", "CallStack", 
                "Modules", "F4SEPlugins", "Plugins" 
            };

            var extractedSegments = ExtractSegments(content.ToList(), segmentBoundaries, "EOF");
            
            // Convert to dictionary with proper names
            var segments = new Dictionary<string, List<string>>();
            
            for (var i = 0; i < segmentNames.Length; i++)
            {
                if (i < extractedSegments.Count)
                {
                    // Strip whitespace from each line in the segment
                    var processedSegment = extractedSegments[i]
                        .Select(line => line.Trim())
                        .Where(line => !string.IsNullOrEmpty(line))
                        .ToList();
                    
                    segments[segmentNames[i]] = processedSegment;
                }
                else
                {
                    // Add empty list for missing segments
                    segments[segmentNames[i]] = new List<string>();
                }
            }

            // Also extract header information (everything before first segment)
            var headerLines = new List<string>();
            foreach (var line in content)
            {
                if (line.StartsWith("\t[Compatibility]") || line.StartsWith("SYSTEM SPECS:"))
                    break;
                headerLines.Add(line.Trim());
            }
            segments["Header"] = headerLines;

            return segments;
        }, cancellationToken);
    }

    /// <summary>
    /// Extracts multiple segments from crash data based on specified boundaries
    /// Port of Python extract_segments function
    /// </summary>
    private static List<List<string>> ExtractSegments(
        List<string> crashData, 
        List<(string start, string end)> segmentBoundaries, 
        string eofMarker)
    {
        var segments = new List<List<string>>();
        var totalLines = crashData.Count;
        var currentIndex = 0;
        var segmentIndex = 0;
        var collecting = false;
        var segmentStartIndex = 0;
        var currentBoundary = segmentBoundaries[0].start;

        while (currentIndex < totalLines && segmentIndex < segmentBoundaries.Count)
        {
            var line = crashData[currentIndex];

            // Check if we've hit a boundary
            if (line.StartsWith(currentBoundary))
            {
                if (collecting)
                {
                    // End of current segment
                    var segmentEndIndex = currentIndex > 0 ? currentIndex - 1 : currentIndex;
                    var segmentContent = crashData.GetRange(segmentStartIndex, segmentEndIndex - segmentStartIndex + 1);
                    segments.Add(segmentContent);
                    segmentIndex++;

                    // Check if we've processed all segments
                    if (segmentIndex >= segmentBoundaries.Count)
                        break;
                }
                else
                {
                    // Start of a new segment
                    segmentStartIndex = currentIndex + 1 < totalLines ? currentIndex + 1 : currentIndex;
                }

                // Toggle collection state and update boundary
                collecting = !collecting;
                if (segmentIndex < segmentBoundaries.Count)
                {
                    currentBoundary = collecting ? 
                        segmentBoundaries[segmentIndex].end : 
                        segmentBoundaries[segmentIndex].start;
                }

                // Handle special EOF case
                if (collecting && currentBoundary == eofMarker)
                {
                    // Add all remaining lines
                    var remainingContent = crashData.GetRange(segmentStartIndex, totalLines - segmentStartIndex);
                    segments.Add(remainingContent);
                    break;
                }

                if (!collecting)
                {
                    // Don't increment index in case current line is also next start boundary
                    currentIndex--;
                }
            }

            // Check if we've reached the end while still collecting
            if (collecting && currentIndex == totalLines - 1)
            {
                var finalContent = crashData.GetRange(segmentStartIndex, totalLines - segmentStartIndex);
                segments.Add(finalContent);
            }

            currentIndex++;
        }

        return segments;
    }

    /// <summary>
    ///     Extracts basic header information from crash log using Python-style parsing
    /// </summary>
    private async Task ExtractHeaderInformationAsync(CrashLog crashLog, string[] content,
        CancellationToken cancellationToken)
    {
        await Task.Run(() =>
        {
            var headerInfo = ParseCrashHeader(content.ToList(), "Buffout", "Fallout4");
            
            crashLog.GameVersion = headerInfo.gameVersion;
            crashLog.CrashGenVersion = headerInfo.crashGenVersion;
            crashLog.MainError = headerInfo.mainError;
        }, cancellationToken);
    }

    /// <summary>
    /// Extract metadata from crash data including game version, crash generator version, and main error.
    /// Port of Python parse_crash_header function.
    /// </summary>
    /// <param name="crashData">List of strings representing lines of the crash data</param>
    /// <param name="crashGenName">Name of the crash generator to be identified</param>
    /// <param name="gameRootName">Root name of the game to identify game version</param>
    /// <returns>Tuple containing game version, crash generator version, and main error</returns>
    private static (string gameVersion, string crashGenVersion, string mainError) ParseCrashHeader(
        List<string> crashData, 
        string crashGenName, 
        string gameRootName)
    {
        var gameVersion = "UNKNOWN";
        var crashGenVersion = "UNKNOWN";
        var mainError = "UNKNOWN";

        foreach (var line in crashData)
        {
            // Check for game version (line starting with game root name)
            if (!string.IsNullOrEmpty(gameRootName) && line.StartsWith(gameRootName))
            {
                gameVersion = line.Trim();
            }
            
            // Check for crash generator version
            if (line.StartsWith(crashGenName))
            {
                crashGenVersion = line.Trim();
            }
            
            // Check for main error (unhandled exception)
            if (line.StartsWith("Unhandled exception"))
            {
                // Replace | with newline for better formatting (first occurrence only)
                var pipeIndex = line.IndexOf('|');
                if (pipeIndex >= 0)
                {
                    mainError = line.Substring(0, pipeIndex) + "\n" + line.Substring(pipeIndex + 1);
                }
                else
                {
                    mainError = line;
                }
            }
        }

        return (gameVersion, crashGenVersion, mainError);
    }

    /// <summary>
    ///     Determines what type of segment a line represents
    /// </summary>
    private string? DetermineSegmentType(string line)
    {
        if (string.IsNullOrWhiteSpace(line))
            return null;

        // Check against known patterns
        if (Regex.IsMatch(line, _patterns.PluginSectionPattern))
            return "Plugins";

        if (Regex.IsMatch(line, _patterns.F4SeSectionPattern))
            return "F4SEPlugins";

        if (Regex.IsMatch(line, _patterns.StackSectionPattern))
            return "CallStack";

        if (Regex.IsMatch(line, _patterns.SystemSpecsPattern))
            return "SystemSpecs";

        if (Regex.IsMatch(line, _patterns.RegistersPattern))
            return "Registers";

        if (Regex.IsMatch(line, _patterns.StackPattern))
            return "Stack";

        if (Regex.IsMatch(line, _patterns.ModulesPattern))
            return "Modules";

        // Check for compatibility section
        if (line.Contains("[Compatibility]"))
            return "Compatibility";

        if (line.Contains("[Crashlog]"))
            return "CrashlogSettings";

        if (line.Contains("[Fixes]"))
            return "Fixes";

        if (line.Contains("[Patches]"))
            return "Patches";

        if (line.Contains("[Warnings]"))
            return "Warnings";

        if (line.Contains("[Tweaks]"))
            return "Tweaks";

        return null;
    }

    /// <summary>
    ///     Extracts date from crash log filename
    /// </summary>
    private DateTime ExtractDateFromFileName(string fileName)
    {
        try
        {
            // Expected format: crash-YYYY-MM-DD-HH-MM-SS.log
            var pattern = @"crash-(\d{4})-(\d{2})-(\d{2})-(\d{2})-(\d{2})-(\d{2})";
            var match = Regex.Match(fileName, pattern);

            if (match.Success)
            {
                var year = int.Parse(match.Groups[1].Value);
                var month = int.Parse(match.Groups[2].Value);
                var day = int.Parse(match.Groups[3].Value);
                var hour = int.Parse(match.Groups[4].Value);
                var minute = int.Parse(match.Groups[5].Value);
                var second = int.Parse(match.Groups[6].Value);

                return new DateTime(year, month, day, hour, minute, second);
            }
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to extract date from filename: {FileName}", fileName);
        }

        // Fallback to current time
        return DateTime.UtcNow;
    }

    /// <summary>
    /// Extracts plugin information from crash log segments
    /// </summary>
    private List<PluginInfo> ExtractPluginList(Dictionary<string, List<string>> segments)
    {
        var plugins = new List<PluginInfo>();

        if (!segments.TryGetValue("Plugins", out var pluginLines))
        {
            _logger.LogDebug("No plugin section found in crash log");
            return plugins;
        }

        try
        {
            var loadOrder = 0;
            var pluginPattern = @"^\s*\[([^\]]+)\]\s*(.+)$"; // [XX] Plugin Name.esp
            var pluginLimitPattern = @"^\s*\[FF\]"; // Plugin limit marker

            foreach (var line in pluginLines)
            {
                if (string.IsNullOrWhiteSpace(line)) continue;

                // Skip header lines
                if (line.Contains("Light:") || line.Contains("Regular:") || line.Contains("Total:"))
                    continue;

                var match = Regex.Match(line, pluginPattern);
                if (match.Success)
                {
                    var loadOrderHex = match.Groups[1].Value.Trim();
                    var pluginName = match.Groups[2].Value.Trim();

                    var hasPluginLimit = Regex.IsMatch(line, pluginLimitPattern);

                    var plugin = new PluginInfo
                    {
                        FileName = pluginName,
                        DisplayName = pluginName,
                        LoadOrder = loadOrder++,
                        IsEsl = pluginName.EndsWith(".esl", StringComparison.OrdinalIgnoreCase),
                        IsEsm = pluginName.EndsWith(".esm", StringComparison.OrdinalIgnoreCase),
                        HasPluginLimit = hasPluginLimit
                    };

                    plugins.Add(plugin);

                    _logger.LogTrace("Parsed plugin: [{LoadOrder}] {PluginName}", 
                        loadOrderHex, pluginName);
                }
            }

            _logger.LogDebug("Extracted {PluginCount} plugins from crash log", plugins.Count);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error extracting plugin list from crash log");
        }

        return plugins;
    }
}

/// <summary>
///     Extension methods for CrashLog parsing
/// </summary>
public static class CrashLogParserExtensions
{
    /// <summary>
    ///     Checks if the crash log has a valid plugin list
    /// </summary>
    public static bool HasValidPluginList(this CrashLog crashLog)
    {
        return crashLog.Segments.ContainsKey("Plugins") &&
               crashLog.Segments["Plugins"].Count > 1; // More than just the header
    }

    /// <summary>
    ///     Gets the plugin count information from the crash log
    /// </summary>
    public static (int light, int regular, int total) GetPluginCounts(this CrashLog crashLog)
    {
        if (!crashLog.Segments.TryGetValue("Plugins", out var pluginLines))
            return (0, 0, 0);

        var countPattern = @"Light:\s*(\d+)\s+Regular:\s*(\d+)\s+Total:\s*(\d+)";

        foreach (var line in pluginLines)
        {
            var match = Regex.Match(line, countPattern);
            if (match.Success)
                return (
                    int.Parse(match.Groups[1].Value),
                    int.Parse(match.Groups[2].Value),
                    int.Parse(match.Groups[3].Value)
                );
        }

        return (0, 0, 0);
    }

    /// <summary>
    ///     Extracts system specifications from the crash log
    /// </summary>
    public static SystemAnalysisResult ExtractSystemSpecs(this CrashLog crashLog)
    {
        var result = new SystemAnalysisResult
        {
            GameVersion = crashLog.GameVersion,
            BuffoutVersion = crashLog.CrashGenVersion
        };

        if (!crashLog.Segments.TryGetValue("SystemSpecs", out var specLines))
            return result;

        var osPattern = @"OS:\s*(.+)$";
        var cpuPattern = @"CPU:\s*(.+)$";
        var gpuPattern = @"GPU #\d+:\s*(.+)$";
        var memoryPattern = @"PHYSICAL MEMORY:\s*(.+?)/(.+?)$";

        foreach (var line in specLines)
        {
            var osMatch = Regex.Match(line, osPattern);
            if (osMatch.Success)
            {
                result.OperatingSystem = osMatch.Groups[1].Value.Trim();
                continue;
            }

            var cpuMatch = Regex.Match(line, cpuPattern);
            if (cpuMatch.Success)
            {
                result.Cpu = cpuMatch.Groups[1].Value.Trim();
                continue;
            }

            var gpuMatch = Regex.Match(line, gpuPattern);
            if (gpuMatch.Success)
            {
                result.GpUs.Add(gpuMatch.Groups[1].Value.Trim());
                continue;
            }

            var memoryMatch = Regex.Match(line, memoryPattern);
            if (memoryMatch.Success)
                result.MemoryInfo = $"{memoryMatch.Groups[1].Value.Trim()}/{memoryMatch.Groups[2].Value.Trim()}";
        }

        return result;
    }

    /// <summary>
    /// Extracts module names from a set of provided module texts.
    /// Port of Python extract_module_names function.
    /// </summary>
    /// <param name="moduleTexts">Set of strings containing module names and optional metadata</param>
    /// <returns>Set of strings representing the extracted module names</returns>
    public static HashSet<string> ExtractModuleNames(IEnumerable<string> moduleTexts)
    {
        var moduleTextsList = moduleTexts.ToList();
        if (!moduleTextsList.Any())
            return new HashSet<string>();

        // Pattern matches module name potentially followed by version
        var pattern = new Regex(@"(.*?\.dll)\s*v?.*", RegexOptions.IgnoreCase);
        var result = new HashSet<string>();

        foreach (var text in moduleTextsList)
        {
            var trimmedText = text.Trim();
            var match = pattern.Match(trimmedText);
            
            if (match.Success)
            {
                result.Add(match.Groups[1].Value);
            }
            else
            {
                result.Add(trimmedText);
            }
        }

        return result;
    }
}
